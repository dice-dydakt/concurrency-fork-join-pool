import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.*;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.lang.reflect.Field;

/**
 * INSTRUMENTED ForkJoin implementation with work-stealing visualization.
 *
 * Tracks:
 * - Task execution times (like ThreadPool instrumented version)
 * - Work-stealing statistics (steals, queue sizes)
 * - Per-thread work distribution
 * - Spatial heatmap of execution times
 */
public class MandelbrotForkJoinTilesInstrumented {
    private final int width;
    private final int height;
    private final int maxIterations;
    private final double xMin, xMax, yMin, yMax;
    private BufferedImage image;

    // Instrumentation data structures
    private final List<TaskTiming> taskTimings = Collections.synchronizedList(new ArrayList<>());
    private final Map<Long, AtomicInteger> threadTaskCounts = new ConcurrentHashMap<>();
    private final Map<String, AtomicInteger> workerThreadTaskCounts = new ConcurrentHashMap<>();

    // Queue size tracking
    private static class QueueSnapshot {
        final long timestampNanos;
        final long queuedSubmissions;  // Tasks in external queue
        final int activeThreadCount;
        final int runningThreadCount;

        public QueueSnapshot(long timestampNanos, long queuedSubmissions,
                           int activeThreadCount, int runningThreadCount) {
            this.timestampNanos = timestampNanos;
            this.queuedSubmissions = queuedSubmissions;
            this.activeThreadCount = activeThreadCount;
            this.runningThreadCount = runningThreadCount;
        }
    }

    private final List<QueueSnapshot> queueSnapshots = Collections.synchronizedList(new ArrayList<>());

    // Local queue size tracking per task
    private static class LocalQueueSample {
        final long threadId;
        final String threadName;
        final int queueLength;
        final long timestampNanos;
        final int tileId;

        public LocalQueueSample(long threadId, String threadName, int queueLength,
                               long timestampNanos, int tileId) {
            this.threadId = threadId;
            this.threadName = threadName;
            this.queueLength = queueLength;
            this.timestampNanos = timestampNanos;
            this.tileId = tileId;
        }
    }

    private final List<LocalQueueSample> localQueueSamples = Collections.synchronizedList(new ArrayList<>());

    /**
     * Get the local queue length for a ForkJoinWorkerThread using reflection.
     * Returns -1 if unable to retrieve (e.g., not a worker thread or reflection fails).
     */
    private static int getLocalQueueLength(Thread thread) {
        if (!(thread instanceof ForkJoinWorkerThread)) {
            return -1;
        }

        try {
            ForkJoinWorkerThread worker = (ForkJoinWorkerThread) thread;

            // Access the workQueue field
            Field workQueueField = ForkJoinWorkerThread.class.getDeclaredField("workQueue");
            workQueueField.setAccessible(true);
            Object queue = workQueueField.get(worker);

            if (queue == null) {
                return 0;
            }

            // Access base and top fields to calculate queue size
            Class<?> queueClass = queue.getClass();
            Field baseField = queueClass.getDeclaredField("base");
            Field topField = queueClass.getDeclaredField("top");
            baseField.setAccessible(true);
            topField.setAccessible(true);

            int base = baseField.getInt(queue);
            int top = topField.getInt(queue);

            return Math.max(0, top - base);
        } catch (Exception e) {
            // Reflection failed - this is expected in some JVM configurations
            return -1;
        }
    }

    public MandelbrotForkJoinTilesInstrumented(int width, int height, int maxIterations) {
        this.width = width;
        this.height = height;
        this.maxIterations = maxIterations;
        this.xMin = -2.5;
        this.xMax = 1.0;
        this.yMin = -1.0;
        this.yMax = 1.0;
    }

    /**
     * Represents a tile with metadata for instrumentation.
     */
    private static class Tile {
        final int id;
        final int startX, startY;
        final int endX, endY;

        public Tile(int id, int startX, int startY, int endX, int endY) {
            this.id = id;
            this.startX = startX;
            this.startY = startY;
            this.endX = endX;
            this.endY = endY;
        }

        public int getWidth() {
            return endX - startX;
        }

        public int getHeight() {
            return endY - startY;
        }
    }

    /**
     * Track which thread forked each task.
     */
    private final Map<TileTask, Long> taskForkThreads = new ConcurrentHashMap<>();

    /**
     * Timing information for a task.
     */
    private static class TaskTiming {
        final Tile tile;
        final long startNanos;
        final long endNanos;
        final long threadId;
        final String threadName;
        final long forkThreadId;
        final boolean wasStolen;

        public TaskTiming(Tile tile, long startNanos, long endNanos,
                         long threadId, String threadName, long forkThreadId) {
            this.tile = tile;
            this.startNanos = startNanos;
            this.endNanos = endNanos;
            this.threadId = threadId;
            this.threadName = threadName;
            this.forkThreadId = forkThreadId;
            // A task was stolen if executed by a different thread than the one that forked it
            this.wasStolen = (forkThreadId != threadId);
        }

        public double getDurationMs() {
            return (endNanos - startNanos) / 1_000_000.0;
        }
    }

    /**
     * Instrumented RecursiveAction that tracks execution and steals.
     */
    private class TileTask extends RecursiveAction {
        private final Tile tile;

        public TileTask(Tile tile) {
            this.tile = tile;
        }

        @Override
        protected void compute() {
            Thread currentThread = Thread.currentThread();
            long threadId = currentThread.getId();
            String threadName = currentThread.getName();

            // Sample local queue size BEFORE executing this task
            int localQueueSize = getLocalQueueLength(currentThread);
            if (localQueueSize >= 0) {
                localQueueSamples.add(new LocalQueueSample(
                    threadId, threadName, localQueueSize,
                    System.nanoTime(), tile.id
                ));
            }

            // Get the thread that forked this task (or current thread if not forked)
            long forkThreadId = taskForkThreads.getOrDefault(this, threadId);

            // Track per-thread statistics
            threadTaskCounts.computeIfAbsent(threadId, k -> new AtomicInteger()).incrementAndGet();

            // Track ForkJoinWorkerThread statistics
            if (threadName.startsWith("ForkJoinPool")) {
                workerThreadTaskCounts.computeIfAbsent(threadName, k -> new AtomicInteger()).incrementAndGet();
            }

            long startTime = System.nanoTime();
            computeTile(tile);
            long endTime = System.nanoTime();

            taskTimings.add(new TaskTiming(tile, startTime, endTime, threadId, threadName, forkThreadId));
        }

        /**
         * Compute all pixels in the tile using hybrid approach.
         */
        private void computeTile(Tile t) {
            int tileWidth = t.endX - t.startX;
            int tileHeight = t.endY - t.startY;
            int[] pixels = new int[tileWidth * tileHeight];
            int index = 0;

            for (int py = t.startY; py < t.endY; py++) {
                for (int px = t.startX; px < t.endX; px++) {
                    double cx = xMin + (xMax - xMin) * px / width;
                    double cy = yMin + (yMax - yMin) * py / height;

                    double iterations = MandelbrotUtils.computeIterations(cx, cy, maxIterations);
                    int color = MandelbrotUtils.iterationsToColor(iterations, maxIterations);

                    pixels[index++] = color;
                }
            }

            image.setRGB(t.startX, t.startY, tileWidth, tileHeight,
                        pixels, 0, tileWidth);
        }
    }

    /**
     * Generate with instrumentation.
     */
    public BufferedImage generate(int tileSize) {
        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        ForkJoinPool pool = ForkJoinPool.commonPool();

        System.out.println("INSTRUMENTED ForkJoin Mandelbrot (PRE-COMPUTED TILES)");
        System.out.println("Image size: " + width + "x" + height);
        System.out.println("Max iterations: " + maxIterations);
        System.out.println("ForkJoinPool parallelism: " + pool.getParallelism());
        System.out.println("Tile size: " + tileSize + "x" + tileSize);
        System.out.println("----------------------------------------");

        // Create all tiles with IDs
        List<TileTask> tasks = new ArrayList<>();
        int tileId = 0;
        int tilesX = 0;
        int tilesY = 0;

        for (int y = 0; y < height; y += tileSize) {
            if (y == 0) tilesX = 0;
            for (int x = 0; x < width; x += tileSize) {
                int endX = Math.min(x + tileSize, width);
                int endY = Math.min(y + tileSize, height);

                Tile tile = new Tile(tileId++, x, y, endX, endY);
                tasks.add(new TileTask(tile));

                if (y == 0) tilesX++;
            }
            tilesY++;
        }

        int totalTiles = tasks.size();
        System.out.println("Total tiles: " + totalTiles + " (" + tilesX + "x" + tilesY + " grid)");

        long startTime = System.nanoTime();

        // Start queue monitoring thread
        AtomicBoolean monitoringActive = new AtomicBoolean(true);
        Thread monitorThread = new Thread(() -> {
            while (monitoringActive.get()) {
                long timestamp = System.nanoTime();
                queueSnapshots.add(new QueueSnapshot(
                    timestamp,
                    pool.getQueuedSubmissionCount(),
                    pool.getActiveThreadCount(),
                    pool.getRunningThreadCount()
                ));
                try {
                    Thread.sleep(1); // Sample every 1ms
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.start();

        // Fork all tasks - record which thread forked each one
        long forkThreadId = Thread.currentThread().getId();
        for (TileTask task : tasks) {
            taskForkThreads.put(task, forkThreadId);
            task.fork();
        }

        // Join all tasks
        for (TileTask task : tasks) {
            task.join();
        }

        long endTime = System.nanoTime();

        // Stop monitoring
        monitoringActive.set(false);
        try {
            monitorThread.join(100); // Wait up to 100ms for monitor thread
        } catch (InterruptedException e) {
            // Ignore
        }

        double elapsedSeconds = (endTime - startTime) / 1_000_000_000.0;
        System.out.printf("Generation time: %.3f seconds%n", elapsedSeconds);

        // Print statistics
        printStatistics(tilesX, tilesY, pool);

        return image;
    }

    /**
     * Print comprehensive statistics.
     */
    private void printStatistics(int tilesX, int tilesY, ForkJoinPool pool) {
        System.out.println();
        System.out.println("======================================================================");
        System.out.println("TASK EXECUTION TIME STATISTICS");
        System.out.println("======================================================================");

        // Calculate basic statistics
        double minTime = taskTimings.stream().mapToDouble(TaskTiming::getDurationMs).min().orElse(0);
        double maxTime = taskTimings.stream().mapToDouble(TaskTiming::getDurationMs).max().orElse(0);
        double avgTime = taskTimings.stream().mapToDouble(TaskTiming::getDurationMs).average().orElse(0);
        double totalTime = taskTimings.stream().mapToDouble(TaskTiming::getDurationMs).sum();

        System.out.printf("Total tasks:     %d%n", taskTimings.size());
        System.out.printf("Min time:        %.3f ms%n", minTime);
        System.out.printf("Max time:        %.3f ms%n", maxTime);
        System.out.printf("Average time:    %.3f ms%n", avgTime);
        System.out.printf("Variability:     %.1fx (max/min ratio)%n", maxTime / minTime);

        // ForkJoinPool statistics
        System.out.println();
        System.out.println("======================================================================");
        System.out.println("FORKJOIN POOL & WORK DISTRIBUTION STATISTICS");
        System.out.println("======================================================================");

        // Get ForkJoinPool stats
        long totalTasks = taskTimings.size();
        int parallelism = pool.getParallelism();

        // Count actual steals (tasks executed by different thread than the one that forked them)
        long actualSteals = taskTimings.stream()
            .filter(t -> t.wasStolen)
            .count();

        long localExecutions = totalTasks - actualSteals;

        System.out.printf("ForkJoinPool stats:%n");
        System.out.printf("  Parallelism:     %d threads%n", parallelism);
        System.out.printf("  Total tasks:     %d%n", totalTasks);
        System.out.printf("  Local executions: %d (%.1f%%)%n",
                         localExecutions, (localExecutions * 100.0) / totalTasks);
        System.out.printf("  Stolen tasks:    %d (%.1f%%)%n",
                         actualSteals, (actualSteals * 100.0) / totalTasks);
        System.out.printf("  Avg tasks/thread: %.1f%n", totalTasks / (double)parallelism);

        // Per-worker-thread statistics
        System.out.println();
        System.out.println("PER-THREAD WORK DISTRIBUTION:");

        List<String> sortedThreadNames = new ArrayList<>(workerThreadTaskCounts.keySet());
        sortedThreadNames.sort(String::compareTo);

        int totalAssigned = 0;
        for (String threadName : sortedThreadNames) {
            int taskCount = workerThreadTaskCounts.get(threadName).get();
            totalAssigned += taskCount;

            // Count steals for this thread (tasks stolen by this thread from others)
            long threadSteals = taskTimings.stream()
                .filter(t -> t.threadName.equals(threadName) && t.wasStolen)
                .count();

            // Calculate average time for this thread
            double threadAvgTime = taskTimings.stream()
                .filter(t -> t.threadName.equals(threadName))
                .mapToDouble(TaskTiming::getDurationMs)
                .average()
                .orElse(0);

            double threadTotalTime = taskTimings.stream()
                .filter(t -> t.threadName.equals(threadName))
                .mapToDouble(TaskTiming::getDurationMs)
                .sum();

            System.out.printf("  %s: %3d tasks (%d stolen), avg %.3f ms, total %.3f ms%n",
                             threadName, taskCount, threadSteals, threadAvgTime, threadTotalTime);
        }

        System.out.printf("%nTotal tasks executed: %d%n", totalAssigned);

        // Calculate load balance
        if (!workerThreadTaskCounts.isEmpty()) {
            int maxTasks = workerThreadTaskCounts.values().stream()
                .mapToInt(AtomicInteger::get).max().orElse(0);
            int minTasks = workerThreadTaskCounts.values().stream()
                .mapToInt(AtomicInteger::get).min().orElse(0);
            double avgTasks = totalAssigned / (double)workerThreadTaskCounts.size();

            System.out.printf("Task distribution: min=%d, max=%d, avg=%.1f%n",
                             minTasks, maxTasks, avgTasks);
            System.out.printf("Distribution range: %d tasks (%.1f%% of avg)%n",
                             maxTasks - minTasks, ((maxTasks - minTasks) / avgTasks) * 100);
        }

        // Load balance analysis - compare per-thread total work times
        System.out.println();
        System.out.println("LOAD BALANCING IMPACT:");

        // Calculate per-thread total times
        double idealThreadTime = totalTime / parallelism;

        double maxThreadTime = workerThreadTaskCounts.keySet().stream()
            .mapToDouble(threadName -> taskTimings.stream()
                .filter(t -> t.threadName.equals(threadName))
                .mapToDouble(TaskTiming::getDurationMs)
                .sum())
            .max()
            .orElse(0);

        double minThreadTime = workerThreadTaskCounts.keySet().stream()
            .mapToDouble(threadName -> taskTimings.stream()
                .filter(t -> t.threadName.equals(threadName))
                .mapToDouble(TaskTiming::getDurationMs)
                .sum())
            .min()
            .orElse(0);

        double imbalance = maxThreadTime - idealThreadTime;
        double efficiency = (idealThreadTime / maxThreadTime) * 100;

        System.out.printf("  Ideal thread time (perfect balance): %.3f ms%n", idealThreadTime);
        System.out.printf("  Slowest thread total time:           %.3f ms%n", maxThreadTime);
        System.out.printf("  Fastest thread total time:           %.3f ms%n", minThreadTime);
        System.out.printf("  Time imbalance:                      %.3f ms (%.1f%%)%n",
                         imbalance, (imbalance / maxThreadTime) * 100);
        System.out.printf("  Load balance efficiency:             %.1f%%%n", efficiency);

        if (efficiency < 70) {
            System.out.println();
            System.out.println("  ⚠ Poor load balancing detected!");
            System.out.println("  Note: With " + totalTasks + " tasks on " + parallelism + " threads,");
            System.out.println("        tiles may be too large for effective work-stealing.");
            System.out.println("  Try: Smaller tiles to create more steal opportunities.");
        } else {
            System.out.println();
            System.out.println("  ✓ Good load balance! Work-stealing helping distribute work.");
            System.out.printf("     %d steals occurred to rebalance workload.%n", actualSteals);
        }

        // Queue dynamics
        printQueueDynamics();

        // Spatial heatmap
        printSpatialHeatmap(tilesX, tilesY);

        // Slowest tiles
        System.out.println();
        System.out.println("SLOWEST 10 TILES:");
        taskTimings.stream()
            .sorted((a, b) -> Double.compare(b.getDurationMs(), a.getDurationMs()))
            .limit(10)
            .forEach(t -> System.out.printf("  Tile #%d at (%d,%d): %.3f ms (thread: %s)%n",
                                           t.tile.id, t.tile.startX, t.tile.startY,
                                           t.getDurationMs(), t.threadName));
    }

    /**
     * Print queue dynamics over time.
     */
    private void printQueueDynamics() {
        if (queueSnapshots.isEmpty()) {
            System.out.println();
            System.out.println("======================================================================");
            System.out.println("QUEUE DYNAMICS");
            System.out.println("======================================================================");
            System.out.println("(No queue samples collected - execution too fast)");
            return;
        }

        System.out.println();
        System.out.println("======================================================================");
        System.out.println("QUEUE DYNAMICS (WORK-STEALING IN ACTION)");
        System.out.println("======================================================================");

        long startNanos = queueSnapshots.get(0).timestampNanos;
        long endNanos = queueSnapshots.get(queueSnapshots.size() - 1).timestampNanos;
        double durationMs = (endNanos - startNanos) / 1_000_000.0;

        System.out.printf("Monitoring duration: %.1f ms (%d samples)%n",
                         durationMs, queueSnapshots.size());

        // Statistics
        long maxQueued = queueSnapshots.stream()
            .mapToLong(s -> s.queuedSubmissions)
            .max()
            .orElse(0);

        double avgQueued = queueSnapshots.stream()
            .mapToLong(s -> s.queuedSubmissions)
            .average()
            .orElse(0);

        int maxActive = queueSnapshots.stream()
            .mapToInt(s -> s.activeThreadCount)
            .max()
            .orElse(0);

        int maxRunning = queueSnapshots.stream()
            .mapToInt(s -> s.runningThreadCount)
            .max()
            .orElse(0);

        System.out.printf("External queue: max=%d, avg=%.1f tasks%n", maxQueued, avgQueued);
        System.out.printf("Active threads: max=%d%n", maxActive);
        System.out.printf("Running threads: max=%d%n", maxRunning);

        // Show timeline visualization (sample every N snapshots to fit in ~60 chars)
        System.out.println();
        System.out.println("Queue size over time (external submission queue):");

        int displayWidth = 60;
        int step = Math.max(1, queueSnapshots.size() / displayWidth);

        StringBuilder timeline = new StringBuilder("  ");
        for (int i = 0; i < queueSnapshots.size(); i += step) {
            long queued = queueSnapshots.get(i).queuedSubmissions;
            if (queued == 0) {
                timeline.append(" ");
            } else if (queued < maxQueued * 0.2) {
                timeline.append("░");
            } else if (queued < maxQueued * 0.4) {
                timeline.append("▒");
            } else if (queued < maxQueued * 0.6) {
                timeline.append("▓");
            } else {
                timeline.append("█");
            }
        }

        System.out.println(timeline.toString());
        System.out.printf("  (Peak: %d tasks waiting to be stolen)%n", maxQueued);
        System.out.println();
        System.out.println("Interpretation:");
        System.out.println("  - High queue at start: Tasks being forked faster than stolen");
        System.out.println("  - Queue drops to zero: Work-stealing distributed all tasks");
        System.out.println("  - More threads active = better parallelism");

        // Print local queue statistics
        printLocalQueueStatistics();
    }

    /**
     * Print local deque statistics for each worker thread.
     */
    private void printLocalQueueStatistics() {
        if (localQueueSamples.isEmpty()) {
            System.out.println();
            System.out.println("======================================================================");
            System.out.println("LOCAL QUEUE DYNAMICS");
            System.out.println("======================================================================");
            System.out.println("(Local queue tracking not available - reflection may have failed)");
            System.out.println();
            System.out.println("To enable local queue tracking, run with:");
            System.out.println("  java --add-opens java.base/java.util.concurrent=ALL-UNNAMED -cp bin ...");
            return;
        }

        System.out.println();
        System.out.println("======================================================================");
        System.out.println("LOCAL QUEUE DYNAMICS (PER-WORKER DEQUES)");
        System.out.println("======================================================================");

        // Group samples by thread
        Map<String, List<LocalQueueSample>> samplesByThread = new TreeMap<>();
        for (LocalQueueSample sample : localQueueSamples) {
            samplesByThread.computeIfAbsent(sample.threadName, k -> new ArrayList<>()).add(sample);
        }

        System.out.printf("Collected %d local queue samples from %d worker threads%n",
                         localQueueSamples.size(), samplesByThread.size());
        System.out.println();

        // Print statistics for each thread
        for (Map.Entry<String, List<LocalQueueSample>> entry : samplesByThread.entrySet()) {
            String threadName = entry.getKey();
            List<LocalQueueSample> samples = entry.getValue();

            int maxQueue = samples.stream().mapToInt(s -> s.queueLength).max().orElse(0);
            double avgQueue = samples.stream().mapToInt(s -> s.queueLength).average().orElse(0);
            int minQueue = samples.stream().mapToInt(s -> s.queueLength).min().orElse(0);

            System.out.printf("%s:%n", threadName);
            System.out.printf("  Samples: %d, Queue: min=%d, max=%d, avg=%.1f%n",
                             samples.size(), minQueue, maxQueue, avgQueue);

            // Show queue evolution timeline (sample subset to fit display)
            int displayWidth = 50;
            int step = Math.max(1, samples.size() / displayWidth);
            StringBuilder timeline = new StringBuilder("    ");

            for (int i = 0; i < samples.size(); i += step) {
                int queueSize = samples.get(i).queueLength;
                if (maxQueue == 0) {
                    timeline.append(" ");
                } else if (queueSize == 0) {
                    timeline.append("·");
                } else if (queueSize < maxQueue * 0.25) {
                    timeline.append("░");
                } else if (queueSize < maxQueue * 0.5) {
                    timeline.append("▒");
                } else if (queueSize < maxQueue * 0.75) {
                    timeline.append("▓");
                } else {
                    timeline.append("█");
                }
            }

            System.out.println(timeline.toString());
            System.out.println();
        }

        System.out.println("Interpretation:");
        System.out.println("  · = Empty queue (thread is stealing from external queue)");
        System.out.println("  ░▒▓█ = Queue has tasks (darker = more tasks waiting)");
        System.out.println();
        System.out.println("Note: In this pre-computed tiles pattern, local queues stay empty!");
        System.out.println("  - All tasks forked by main thread → external submission queue");
        System.out.println("  - Workers steal from external queue, not from each other's deques");
        System.out.println("  - Local deques would fill up only in recursive fork-join patterns");
        System.out.println("    (where workers fork sub-tasks during compute())");
    }

    /**
     * Print ASCII heatmap of spatial distribution.
     */
    private void printSpatialHeatmap(int tilesX, int tilesY) {
        System.out.println();
        System.out.println("SPATIAL DISTRIBUTION OF EXECUTION TIMES:");
        System.out.println("  (Heatmap: darker = longer execution time)");
        System.out.println();

        // Build map of execution times by position
        Map<String, Double> timeByPosition = new HashMap<>();
        double maxTime = 0;
        double minTime = Double.MAX_VALUE;

        for (TaskTiming t : taskTimings) {
            String key = t.tile.startX + "," + t.tile.startY;
            double duration = t.getDurationMs();
            timeByPosition.put(key, duration);
            maxTime = Math.max(maxTime, duration);
            minTime = Math.min(minTime, duration);
        }

        // Print heatmap
        String[] intensityChars = {" ", "░", "▒", "▓", "█"};
        int tileSize = (tilesX > 0) ? width / tilesX : 100;

        for (int y = 0; y < height; y += tileSize) {
            System.out.print("  ");
            for (int x = 0; x < width; x += tileSize) {
                String key = x + "," + y;
                Double time = timeByPosition.get(key);

                if (time != null) {
                    double normalized = (time - minTime) / (maxTime - minTime + 0.001);
                    int intensity = (int)(normalized * (intensityChars.length - 1));
                    System.out.print(intensityChars[intensity]);
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }

        System.out.printf("  Legend: '%s' = %.2fms, '%s' = %.2fms%n",
                         intensityChars[0], minTime,
                         intensityChars[intensityChars.length - 1], maxTime);
    }

    public void saveImage(BufferedImage image, String filename) throws IOException {
        File outputFile = new File(filename);
        ImageIO.write(image, "PNG", outputFile);
        System.out.println("Image saved to: " + filename);
    }

    public static void main(String[] args) {
        int width = 1600;
        int height = 1200;
        int maxIterations = 2000;
        int tileSize = 50;

        if (args.length >= 3) {
            width = Integer.parseInt(args[0]);
            height = Integer.parseInt(args[1]);
            maxIterations = Integer.parseInt(args[2]);
        }
        if (args.length >= 4) {
            tileSize = Integer.parseInt(args[3]);
        }

        MandelbrotForkJoinTilesInstrumented mandelbrot =
            new MandelbrotForkJoinTilesInstrumented(width, height, maxIterations);

        long startTime = System.nanoTime();
        BufferedImage image = mandelbrot.generate(tileSize);
        long endTime = System.nanoTime();

        double elapsedSeconds = (endTime - startTime) / 1_000_000_000.0;
        System.out.printf("%nTotal time: %.3f seconds%n", elapsedSeconds);

        try {
            mandelbrot.saveImage(image, "mandelbrot_forkjoin_instrumented_tile" + tileSize + ".png");
        } catch (IOException e) {
            System.err.println("Error saving image: " + e.getMessage());
        }
    }
}
